**Tally API Guide**

**Introduction to the Tally API**

Welcome to the Tally API! This document serves as a guide for Large Language Models (LLMs) and AI tools to effectively interact with Tally's GraphQL API. This API provides access to data about Governor contracts, their proposals, and the accounts that participate in on-chain DAOs. With it, you can create data-driven experiences that are connected to on-chain governance. 

**Key Aspects to Understand**

*   **Data Source:** The Tally API pulls data from multiple blockchains, providing a comprehensive view of decentralized governance.
*   **GraphQL:** The API uses GraphQL, allowing for precise requests for data and responses containing only the information that has been requested. 
*   **Focus on Governance:** This API is specifically designed for accessing governance-related data on decentralized organizations (DAOs).

**Getting Started**

1.  **API Key Required:** You'll need a Tally API key to use the API. You can create one by logging into Tally and requesting a key on the [user settings page](https://www.tally.xyz/user/settings). The API key should be included in the HTTP header of each request, like so:

    ```
    Api-Key: YOUR_KEY_HERE
    ```

2.  **GraphQL Playground:** You can test and experiment with the API using the [GraphQL API Playground](https://api.tally.xyz/playground). Add your API key under the "Request Headers" section, like this: `{"Api-Key":"YOUR_KEY_HERE"}`.
    *   Note: The playground also includes undocumented endpoints. These are not recommended for production, as they may change without notice.

3.  **Quickstart Example:** A helpful [quickstart example](https://github.com/withtally/tally-api-quickstart) is available on GitHub, which shows how to use the API with a React app.

4.  **Rate Limits:** Because this API is free for use, we have implemented rate limiting to keep costs down. If you are interested in an increased rate limit, please contact us at <a href="mailto:support@tally.xyz">support@tally.xyz</a>.

5. **Community:** Join our community on Discord for more help and guidance [https://discord.com/invite/sCGnpWH3m4](https://discord.com/invite/sCGnpWH3m4)

**License and Terms**

* This API is governed by an [Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0.html) license.
* The Tally terms of service can be found here: [https://static.tally.xyz/terms.html](https://static.tally.xyz/terms.html)

**API Endpoint**
* API Endpoints: `https://api.tally.xyz/query`

**How to Use this Guide**

This document details all of the methods and types in the Tally API, and it uses examples and guidelines that an LLM can use to quickly and easily construct a valid Tally API request. Be sure to pay attention to the data types and relationships between them when making queries, and make liberal use of fragments to organize your queries efficiently.


**1. Schema Overview**

This section provides a high-level overview of core types and their relationships to enable LLMs to quickly understand the data structure.

```graphql
# Core Types Overview

type Account {
  id: ID!
  address: String!
  ens: String
  twitter: String
  name: String!
  bio: String!
  picture: String
  safes: [AccountID!]
  type: AccountType!
  votes: Uint256!
  proposalsCreatedCount: Int!
}

type Delegate {
  id: IntID!
  account: Account!
  chainId: ChainID
  delegatorsCount: Int!
  governor: Governor
  organization: Organization
  statement: DelegateStatement
  token: Token
  votesCount: Uint256!
}

type Delegation {
  id: IntID!
  blockNumber: Int!
  blockTimestamp: Timestamp!
  chainId: ChainID!
  delegator: Account!
  delegate: Account!
  organization: Organization!
  token: Token!
  votes: Uint256!
}

type Governor {
    id: AccountID!
    chainId: ChainID!
    contracts: Contracts!
    isIndexing: Boolean!
    isBehind: Boolean!
    isPrimary: Boolean!
    kind: GovernorKind!
    name: String!
    organization: Organization!
    proposalStats: ProposalStats!
    parameters: GovernorParameters!
    quorum: Uint256!
    slug: String!
    timelockId: AccountID
    tokenId: AssetID!
    token: Token!
    type: GovernorType!
    delegatesCount: Int!
    delegatesVotesCount: Uint256!
    tokenOwnersCount: Int!
    metadata: GovernorMetadata
  }

type Organization {
  id: IntID!
  slug: String!
  name: String!
  chainIds: [ChainID!]!
  tokenIds: [AssetID!]!
  governorIds: [AccountID!]!
  metadata: OrganizationMetadata
  creator: Account
  hasActiveProposals: Boolean!
  proposalsCount: Int!
  delegatesCount: Int!
  delegatesVotesCount: Uint256!
  tokenOwnersCount: Int!
  endorsementService: EndorsementService
}

type Proposal {
    id: IntID!
    onchainId: String
    block: Block
    chainId: ChainID!
    creator: Account
    end: BlockOrTimestamp!
    events: [ProposalEvent!]!
    executableCalls: [ExecutableCall!]
    governor: Governor!
    metadata: ProposalMetadata!
    organization: Organization!
    proposer: Account
    quorum: Uint256
    status: ProposalStatus!
    start: BlockOrTimestamp!
    voteStats: [VoteStats!]
}

type Token {
    id: AssetID!
    type: TokenType!
    name: String!
    symbol: String!
    supply: Uint256!
    decimals: Int!
    eligibility: Eligibility
    isIndexing: Boolean!
    isBehind: Boolean!
  }
type Vote {
      id: IntID!
        amount: Uint256!
        block: Block!
        chainId: ChainID!
        isBridged: Boolean
        proposal: Proposal!
        reason: String
        type: VoteType!
        txHash: Hash!
        voter: Account!
    }


# ... (other core types can be added here if necessary for clarity)
```

**2. Fragments: The Basics**

Fragments are reusable sets of fields. They help keep your GraphQL queries clean, organized, and efficient.

**2.1. Defining Fragments:**

Use the `fragment` keyword followed by a name and the type.

```graphql
fragment BasicAccountInfo on Account {
  id
  address
  ens
}

fragment DelegateBasics on Delegate {
    id
    votesCount
    delegatorsCount
  }
```

**2.2. Using Fragments:**

Use the spread operator `...` to include a fragment within a selection set.

```graphql
query GetAccountAndDelegate($accountId: AccountID!, $delegateInput: DelegateInput!) {
    account(id: $accountId) {
      ...BasicAccountInfo
    }
    delegate(input: $delegateInput) {
        ...DelegateBasics
    }
}
```

**3. Example Queries with Fragments**

This section illustrates how fragments are used to compose queries of varying complexity.

**3.1. Basic Example: Single Fragment, One Type**

```graphql
# Example 1: Basic Account Query with Fragment
fragment AccountBasics on Account {
  id
  address
  ens
}

query GetBasicAccount($accountId: AccountID!) {
  account(id: $accountId) {
    ...AccountBasics
  }
}
```

**3.2. Intermediate Example: Multiple Fragments, Related Types**

```graphql
# Example 2: Delegate Query with Account Fragment
fragment DelegateWithAccountInfo on Delegate {
   id
    account {
        ...AccountBasics
       }
    votesCount
    }

  fragment AccountBasics on Account {
    id
    address
    ens
  }

query GetDelegate {
     delegate(input: { address: "0x123", governorId:"123"}) {
       ...DelegateWithAccountInfo
     }
   }
```

**3.3. Advanced Example: Nested Fragments, Conditional Fields**

```graphql
  fragment ProposalDetails on Proposal {
    id
    onchainId
     metadata {
      title
      description
    }
   status
     start {
        ... on Block {
          id
          timestamp
        }
         ... on BlocklessTimestamp {
            timestamp
          }
    }
    governor {
      id
      chainId
      contracts {
         governor {
            address
          }
        }
    }
  }

fragment ExecutableCallDetails on ExecutableCall{
  signature
        target
          value
        decodedCalldata {
          signature
           parameters {
              name
              type
              value
             }
          }
 }

query GetProposalWithAction($proposalInput: ProposalInput!) {
  proposal(input: $proposalInput) {
    ...ProposalDetails
        executableCalls {
         ...ExecutableCallDetails
       }
   }
}
```

**4. Pattern Recognition Guide for LLMs**

*   **`... on Type`:**  Indicates a fragment spread. The fields within the fragment are applied to the current selection at that point, within the context of the given type.
*   **Multiple Fragments on the Same Type:**  Look for reusable sets of fields for specific types.
*   **Nested Fragments**: Can show parent-child relationships within data, indicating that a fragment uses other fragments as part of its field selections.

**5. Query Construction Steps**

Here's a decision tree to guide LLMs on composing queries:

1.  **Identify Required Data Types:** Determine the core GraphQL types needed.
2.  **Check for Existing Fragments:** Look for fragments that match your data requirements.
3.  **Create New Fragments (if needed):** Compose a new fragment if no existing fragment matches.
4.  **Compose the Query:** Assemble the query by spreading appropriate fragments, aiming for clarity and minimal over-fetching.

**6. Fragment Validation Rules for LLMs**

*   **Unique Names:** Fragment names must be unique within a GraphQL document.
*   **Valid Type:** The type after `on` (e.g., `on Account`) must exist in the schema.
*   **Valid Fields:** Fields referenced within a fragment must exist on the specified type.
*   **No Circular References:** Avoid creating fragments that refer to themselves directly or indirectly.
*   **Type Compatibility:** Spread operator (`...`) should only be used on fields of the matching type.

**7. Common Fragment Errors (LLM Training Data)**

*   **Type Mismatch:** Using an `AccountBasics` fragment where a `Delegate` is expected.
*   **Unknown Fields:** Requesting a field that doesn't exist on the specified type (e.g., requesting `votes` on an Account when you are expecting a Delegation.)
*   **Circular References:** Fragment A references fragment B, which references fragment A.
*   **Fragment not defined**: Spreading a fragment which has not been declared.

**8. LLM Processing Guidelines**

*   **Parse Schema First:** Load and analyze the Tally API schema to understand the types, relationships, and available fields.
*   **Index Fragments:** Create a searchable index of fragments from examples or the schema itself for efficient reuse.
*   **Match Fragment Patterns:** Identify fragments that fit the data type and desired field set in query requirements.
*  **Type Checking** If there are types being used in an input or as a value, ensure that the type is valid.
*   **Validate Fragment Composition:** When composing a query with fragments, check that types match at each spread location and no circular references exists.
* **Minimization of fields:** Use fragments to select the required fields, to reduce the amount of data fetched from the API.

**9. Fragment Composition Patterns**

This section demonstrates advanced techniques for using fragments effectively to build complex queries.

**9.1. Combining Multiple Fragments:**

When you have multiple fragments that provide different parts of your query, simply include them in a top-level query, or another fragment, using the spread syntax (`...`). This allows you to reuse these fragments to compose more complex data requests.
```graphql
fragment GovernorDetails on Governor {
  id
  name
  chainId
   contracts {
      governor {
        address
         type
      }
    }
}

fragment GovernorOrgInfo on Governor {
  organization {
     name
     metadata {
       icon
       description
      }
   }
}

query GetGovernorAndOrgInfo($input: GovernorInput!) {
    governor(input: $input) {
        ...GovernorDetails
      ...GovernorOrgInfo
    }
}
```

**9.2. Nested Fragment Scenarios:**

If you have hierarchical data, your fragments can also be nested. This is often used for nested types that share common fields, such as in this example:

```graphql
fragment AccountDetails on Account {
  id
  address
  ens
  twitter
  name
  bio
  picture
}

fragment DelegationDetails on Delegation {
  id
  delegator {
      ...AccountDetails
  }
  delegate {
     ...AccountDetails
  }
  organization {
        name
      metadata{
          icon
       }
    }
    votes
}

query GetDelegationDetails($input: DelegationInput!) {
    delegatee(input: $input) {
       ...DelegationDetails
    }
}
```

**9.3. Handling Pagination in Fragments**

When dealing with paginated data, incorporate the `pageInfo` fields directly within a fragment. This is also useful if you use the spread operator for `PageInfo` in multiple queries.

```graphql
fragment PaginatedDelegates on Delegation {
  id
   delegator {
    address
    name
   }
  delegate {
    address
    name
  }
    votes
    organization {
      name
      slug
    }
  }

fragment PageInfoFields on PaginatedOutput {
  pageInfo {
    firstCursor
    lastCursor
    count
  }
}

query GetPaginatedDelegates($input: DelegationsInput!) {
  delegatees(input: $input) {
    nodes {
       ...PaginatedDelegates
      }
    ...PageInfoFields
    }
}
```
**9.4. Conditional Fragment Selection**

While conditional inclusion of fields within a fragment is not directly possible using `@include` or `@skip`, you can implement a fragment to get fields for several types via union types.

```graphql
fragment NodeDetails on Node {
  ... on Account {
    name
  }
  ... on Proposal {
    status
    metadata {
      description
      title
      }
    }
  ... on Governor {
      name
    }
    ... on Delegation {
        votes
    }
}

query GetNodeDetails($input: IntID!) {
  node(id: $input) {
    ...NodeDetails
  }
}
```

**10. LLM Best Practices for Fragment Composition**

*   **Modularity:** Create specific fragments for related fields, then mix and match.
*   **Hierarchy:** Use nested fragments if needed.
*   **Avoid Over-Nesting:** Keep the fragment nesting at reasonable depths.
*   **Name Appropriately:** Use descriptive and meaningful fragment names.
*   **Prioritize Reuse:** Identify common field combinations and define fragments for reuse.
*   **Combine Fragments:** Combine single-use and commonly-used fragments to increase reusability.
*   **Readability:** Keep fragments concise; too many fields in a single fragment can reduce readability.
*   **Data Structure Awareness:** Ensure fragments align with your data structure so the query results match what you expect.

**Summary:**

* Fragments are reusable pieces of query logic, making queries more efficient and maintainable.
* Fragments are used with the `fragment` keyword and the spread operator `...`.
* Fragments should match the type on which they are used.
*   Combine multiple fragments into one query using the spread operator
*   Fragments can be nested to define hierarchical relationships
*   Use union types to implement conditional inclusion of fields into a fragment
*   Create fragments with sensible names, keep them small and focused for clarity
*   Utilize pagination fragments when making use of paginated queries

