This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-07T03:07:08.472Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
docs/
  LLM-API-GUIDE-2.txt
  Tally API Docs LLM Overview.txt
prompts/
  query-metadata.txt
  service-description.txt
  system-prompt.txt
  tool-metadata.txt
src/
  services/
    expertService.ts
  index.ts
  server.ts
  setup.ts
.env.example
.gitignore
docs.txt
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: docs/LLM-API-GUIDE-2.txt
================
Tally API - LLM Query Construction Rules (Mandatory & Unbreakable)

Introduction

This document outlines the mandatory and unbreakable rules for Large Language Models (LLMs) when constructing queries for the Tally API. These rules are not suggestionsâ€”they must be strictly followed to ensure correct, efficient, and error-free GraphQL queries. Failure to adhere to any of these rules will result in a fatal error, and the LLM must immediately terminate the current query and return an error message indicating which rule was broken. There is no acceptable deviation whatsoever from these rules.

Core Principles

Never Assume: Under no circumstances should the LLM assume any default values or behaviors for sort, filter, or other optional input parameters. You must explicitly declare them in the query.

Type Awareness: You must always be acutely aware of the GraphQL types involved, especially interface and union types, and use inline fragments accordingly. Failure to do so is a fatal error and will result in immediate termination of the query.

Fragment Prioritization: You must use fragments to minimize repetition, improve maintainability, and ensure efficient queries. Not using fragments is absolutely unacceptable and will result in a fatal error.

Explicit Field Selection: You must always explicitly request each field you need, and never assume fields will be returned automatically.

Pagination: You must always use pagination where appropriate to ensure complete query results are retrieved, using the page input and pageInfo fields.

Correct API Use: You must adhere to API constraints. Some queries have required fields that must be used correctly.

Schema Consultation: You must consult the complete schema reference before creating any queries.

Multi-step Queries: You must properly structure multi-step queries into a sequence of dependent queries if data from one query is needed for a subsequent query.

Fragment Usage: All Fragments must be used, and any unused fragments must be removed before the query can be submitted.

Data Verification: You must not invent data. If you use external data to construct a query, you must attempt to verify the correctness of that data before using it. If you cannot verify the data, you must explicitly state that the data is unverified, and not present it as a fact. Failure to do so is a fatal error.

Rule 1: Interface and Union Type Handling (Mandatory)

Problem: The nodes field in paginated queries often returns a list of types that implement a GraphQL interface (like Node), or are part of a union type. You cannot query fields directly on the interface type.

Solution: You must use inline fragments (... on TypeName) to access fields on the concrete types within a list of interface types. Failure to do so is a fatal error and will result in immediate termination of the query.

Example (Correct):

query GetOrganizations {
  organizations {
    nodes {
      ... on Organization {
        id
        name
        slug
        metadata {
          icon
        }
      }
    }
    pageInfo {
      firstCursor
      lastCursor
      count
    }
  }
}
content_copy
download
Use code with caution.
Graphql

Example (Incorrect - Avoid):

query GetOrganizations {
  organizations {
    nodes {
      id
      name
      slug
    }
  }
}
content_copy
download
Use code with caution.
Graphql

Specific Error Case: Attempting to query fields directly on the nodes field when querying votes without the ... on Vote fragment. This is a fatal error and will result in immediate termination of the query.

query GetVotes {
  votes(input: {
    filters: {
      voter: "0x1B686eE8E31c5959D9F5BBd8122a58682788eeaD"
    }
  }) {
    nodes {
      type
    }
  }
}
content_copy
download
Use code with caution.
Graphql

Action: Always use inline fragments (... on TypeName) inside the nodes list, and any other location where interface types can be returned, to query the specific fields of the concrete type. Failure to do so is a fatal error and will result in immediate termination of the query.

Rule 2: Explicit Sort and Filter Inputs (Mandatory)

Problem: Queries with sort or filter options often have required input types that must be fully populated.

Solution: You must never assume default sort or filter values. You must always explicitly provide them in the query if you need them. Even if you don't need sorting or filtering, you must provide an empty input object.

Example (Correct):

query GetProposals($input: ProposalsInput!) {
  proposals(input: $input) {
    nodes {
        ... on Proposal {
            id
            metadata {
                title
            }
            status
        }
    }
    pageInfo {
      firstCursor
      lastCursor
      count
    }
  }
}
content_copy
download
Use code with caution.
Graphql
*  **Input:**
content_copy
download
Use code with caution.
input ProposalsInput {
    filters: ProposalsFiltersInput
    page: PageInput
    sort: ProposalsSortInput
}

input ProposalsFiltersInput {
    governorId: AccountID
    includeArchived: Boolean
    isDraft: Boolean
    organizationId: IntID
    proposer: Address
}
input ProposalsSortInput {
    isDescending: Boolean!
    sortBy: ProposalsSortBy!
}
enum ProposalsSortBy {
    id
}

input PageInput {
    afterCursor: String
    beforeCursor: String
    limit: Int
}
content_copy
download
Use code with caution.
Graphql
*   **Query:** (with optional sort, and filters)
content_copy
download
Use code with caution.
query GetProposalsWithSortAndFilter {
  proposals(input: {
      filters: {
          governorId: "eip155:1:0x123abc"
          includeArchived: true
      },
      sort: {
        sortBy: id
        isDescending: false
      },
      page: {
        limit: 10
      }
  })
    {
    nodes {
        ... on Proposal {
            id
            metadata {
                title
            }
            status
        }
    }
    pageInfo {
      firstCursor
      lastCursor
       count
    }
  }
}
content_copy
download
Use code with caution.
Graphql

Example (Incorrect - Avoid):

query GetProposals {
  proposals {
    nodes {
      id
      metadata {
        title
      }
      status
    }
  }
}
content_copy
download
Use code with caution.
Graphql

Action: Always provide a valid input object for queries that require filters or sorts. Use null if no sorting or filtering is needed for a nullable input, but if the filter is required, use an empty object when no filters are required. Failure to do so is a fatal error and will result in immediate termination of the query.

Rule 3: Fragment Usage (Mandatory)

Problem: Repeated field selections in multiple queries make the code less maintainable and are prone to errors.

Solution: You must use fragments to group common field selections and reuse them across multiple queries. Not using fragments is absolutely unacceptable and will result in a fatal error.

Example (Correct):

fragment BasicProposalDetails on Proposal {
    id
    onchainId
    metadata {
      title
      description
    }
   status
}


query GetProposals($input: ProposalsInput!) {
  proposals(input: $input) {
    nodes {
        ... on Proposal {
            ...BasicProposalDetails
         }
    }
    pageInfo {
      firstCursor
      lastCursor
       count
    }
  }
}

query GetSingleProposal($input: ProposalInput!) {
    proposal(input: $input) {
      ...BasicProposalDetails
    }
}
content_copy
download
Use code with caution.
Graphql

Example (Incorrect - Avoid):

query GetProposals {
  proposals {
    nodes {
       id
       onchainId
       metadata {
        title
        description
       }
       status
    }
  }
}

query GetSingleProposal {
    proposal(input: {id: 123}) {
      id
      onchainId
      metadata {
        title
        description
      }
      status
    }
}
content_copy
download
Use code with caution.
Graphql

Action: Always create and use fragments, and make them focused, and reusable across multiple queries. Not using fragments is absolutely unacceptable and will result in a fatal error.

Rule 4: Explicit Field Selection (Mandatory)

Problem: Assuming the API will return certain fields if they aren't specifically requested.

Solution: You must always request every field you need in your query.

Example (Correct):

query GetOrganization($input: OrganizationInput!) {
  organization(input: $input) {
    id
    name
    slug
    metadata {
      icon
      description
      socials {
        website
      }
    }
  }
}
content_copy
download
Use code with caution.
Graphql

Example (Incorrect - Avoid):

query GetOrganization {
  organization {
    name
    slug
  }
}
content_copy
download
Use code with caution.
Graphql

Action: List out every field you need in the query, and avoid implied or implicit field selections.

Rule 5: Input Type Validation (Mandatory)

Problem: Using the wrong types when providing input values to a query.

Solution: Check that all values passed as inputs to a query match the type declared in the input. Failure to do so is a fatal error and will result in immediate termination of the query.

Example (Correct):

query GetAccount($id: AccountID!) {
  account(id: $id) {
    id
    name
    address
    ens
    picture
  }
}
content_copy
download
Use code with caution.
Graphql

Query

query GetAccountCorrect {
   account(id:"eip155:1:0x123") {
    id
     name
     address
     ens
     picture
   }
}
content_copy
download
Use code with caution.
Graphql
* The `id` argument correctly uses the `AccountID` type, which is a string representing a CAIP-10 ID.
content_copy
download
Use code with caution.

Specific Error Case: Attempting to use a plain integer for organizationId in proposal queries. This is a fatal error and will result in immediate termination of the query.

query GetProposals {
  proposals(input: {
    filters: {
      organizationId: 1
    }
  })
  {
    nodes {
      ... on Proposal {
          id
         }
      }
   }
}
content_copy
download
Use code with caution.
Graphql

Example (Incorrect - Avoid):

query GetAccount($id: AccountID!) {
  account(id: $id) {
    id
    name
    address
  }
}
content_copy
download
Use code with caution.
Graphql

Query

query GetAccountIncorrect {
   account(id:123) {
    id
     name
     address
     ens
     picture
   }
}
content_copy
download
Use code with caution.
Graphql

Action: Ensure you're using the correct type. Int cannot be used where an IntID, AccountID, HashID or AssetID type is required. Failure to do so is a fatal error and will result in immediate termination of the query.

ID Type Definitions

AccountID: A CAIP-10 compliant account id. (e.g., "eip155:1:0x7e90e03654732abedf89Faf87f05BcD03ACEeFdc")

AssetID: A CAIP-19 compliant asset id. (e.g., "eip155:1/erc20:0x6b175474e89094c44da98b954eedeac495271d0f")

IntID: A 64-bit integer represented as a string. (e.g., "1234567890")

HashID: A CAIP-2 scoped identifier for identifying transactions across chains. (e.g., "eip155:1:0xDEAD")

BlockID: A CAIP-2 scoped identifier for identifying blocks across chains. (e.g., "eip155:1:15672")

ChainID: A CAIP-2 compliant chain ID. (e.g., "eip155:1")

Address: A 20 byte ethereum address, represented as 0x-prefixed hexadecimal. (e.g., "0x1234567800000000000000000000000000000abc")

Rule 6: Enum Usage (Mandatory)

Problem: Using a string value when an enum type is expected.

Solution: Always use the correct values for an enum type. Failure to do so is a fatal error and will result in immediate termination of the query.

Example (Correct)

query GetVotes($input: VotesInput!) {
  votes(input: $input) {
    nodes {
      id
       type
    }
  }
}
content_copy
download
Use code with caution.
Graphql

Input:

input VotesInput {
    filters: VotesFiltersInput
    page: PageInput
    sort: VotesSortInput
}

input VotesFiltersInput {
    proposalId: IntID
    proposalIds: [IntID!]
    voter: Address
    includePendingVotes: Boolean
    type: VoteType
}
enum VoteType {
    abstain
    against
    for
    pendingabstain
    pendingagainst
    pendingfor
}
content_copy
download
Use code with caution.
Graphql

Query: (Correctly using an enum type)

query GetVotesFor {
    votes(input: {
        filters: {
            type: for
             proposalId: 123
        }
    })
    {
      nodes {
        id
          type
      }
    }
}
content_copy
download
Use code with caution.
Graphql

Example (Incorrect - Avoid):

query GetVotesFor {
    votes(input: {
        filters: {
            type: "for"
             proposalId: 123
        }
    })
    {
      nodes {
        id
          type
      }
    }
}
content_copy
download
Use code with caution.
Graphql

Action: Always ensure the values of enum types match the provided options, and that you are not using a string when an enum is expected. Failure to do so is a fatal error and will result in immediate termination of the query.

Rule 7: Pagination Handling (Mandatory)

Problem: Queries that return paginated data do not return complete results if pagination is not handled.

Solution: You must always use the page input with appropriate limit, afterCursor and beforeCursor values to ensure you are retrieving all the results that you want. You must also use the pageInfo field on the returned type to use the cursors.

Example (Correct):

query GetPaginatedProposals($input: ProposalsInput!) {
  proposals(input: $input) {
    nodes {
        ... on Proposal {
            id
            metadata {
                title
            }
        }
    }
   pageInfo {
       firstCursor
       lastCursor
       count
     }
  }
}
content_copy
download
Use code with caution.
Graphql
* **Input**
content_copy
download
Use code with caution.
input ProposalsInput {
    filters: ProposalsFiltersInput
    page: PageInput
    sort: ProposalsSortInput
}

input ProposalsFiltersInput {
    governorId: AccountID
    includeArchived: Boolean
    isDraft: Boolean
    organizationId: IntID
    proposer: Address
}
input ProposalsSortInput {
    isDescending: Boolean!
    sortBy: ProposalsSortBy!
}
enum ProposalsSortBy {
    id
}

input PageInput {
    afterCursor: String
    beforeCursor: String
    limit: Int
}
content_copy
download
Use code with caution.
Graphql

Query:

query GetProposalsWithPagination {
    proposals(input: {
       page: {
           limit: 20
       }
    }) {
        nodes {
            ... on Proposal {
              id
               metadata {
                title
              }
           }
         }
         pageInfo {
           firstCursor
            lastCursor
           count
          }
        }
}
content_copy
download
Use code with caution.
Graphql

Query: (Using cursors to get the next page of results)

query GetProposalsWithPagination {
    proposals(input: {
       page: {
           limit: 20
           afterCursor: "cursorFromPreviousQuery"
       }
    }) {
        nodes {
          ... on Proposal {
            id
            metadata {
                title
              }
           }
        }
         pageInfo {
           firstCursor
            lastCursor
           count
          }
        }
}
content_copy
download
Use code with caution.
Graphql

Example (Incorrect - Avoid):

query GetProposals {
  proposals {
      nodes {
         ... on Proposal {
          id
            metadata {
                title
            }
           }
       }
    }
}
content_copy
download
Use code with caution.
Graphql

Action: Always use the page input with a limit, and use the cursors to iterate through pages, especially when you are working with paginated data. Failure to do so may result in incomplete data.

Rule 8: Correctly Querying Related Data (Mandatory)

Problem: Attempting to query related data as nested fields within a type will lead to errors if the related data must be fetched in a separate query.

Solution: You must fetch related data by using separate queries, instead of assuming that related data is queryable as nested fields.

Example (Correct)

query GetProposalAndVotes($proposalId: IntID!, $voter: Address) {
  proposal(input: { id: $proposalId}) {
    id
    metadata {
      title
    }
    status
  }
  votes(input: {
    filters: {
      proposalId: $proposalId
      voter: $voter
    }
  }) {
    nodes {
      ... on Vote {
        type
        amount
        voter {
          id
          name
        }
      }
    }
  }
}
content_copy
download
Use code with caution.
Graphql

Example (Incorrect - Avoid):

query GetProposals {
  proposals {
    ... on Proposal {
      id
      metadata {
        title
      }
      votes(input: {
        filters: {
          voter: "0x..."
        }
      })
    }
  }
}
content_copy
download
Use code with caution.
Graphql

Action: Do not attempt to fetch related data in the same query, instead, fetch it via a second query. Failure to do so will result in an error.

Rule 9: API Constraints (Mandatory)

Problem: Not all fields or properties are queryable in all situations. Some queries have explicit requirements that must be met.

Solution: You must always check your query against the known API constraints, and ensure that all requirements are met.

Example:

The votes query requires that proposalId or proposalIds is provided in the input. This means you cannot query votes without first querying proposals. Failure to do so will result in an error.

An error you may see is: "proposalId or proposalIds must be provided"

Action: Ensure all API constraits are met and that any required fields are provided when making a query. Failure to do so will result in an error.

Rule 10: Multi-Step Queries (Mandatory)

Problem: Some data can only be accessed by using multiple queries, and requires that data from one query be used as the input for a subsequent query.

Solution: Properly construct multi-step queries by breaking them into a sequence of independent GraphQL queries. Ensure the output of one query is correctly used as input for the next query.

Example

If you need to fetch all the votes from a specific organization, you first need to get the organization id, then use that id to query all the proposals, and then finally, you need to query for all the votes associated with each proposal.

Correct Example

# Step 1: Get the organization ID using a query that filters by slug

query GetOrganizationId($slug: String!) {
  organization(input: {slug: $slug}) {
    id
  }
}

# Step 2: Get the proposals for the given organization
query GetProposalsForOrganization($organizationId: IntID!) {
    proposals(input: {
      filters: {
        organizationId: $organizationId
      }
    }) {
        nodes {
            ... on Proposal {
                id
            }
        }
    }
}

# Step 3: Get all the votes for all of the proposals.
query GetVotesForProposals($proposalIds: [IntID!]!) {
    votes(input: {
      filters: {
         proposalIds: $proposalIds
      }
    })
        {
        nodes {
            ... on Vote {
                id
                type
                amount
            }
        }
    }
}
content_copy
download
Use code with caution.
Graphql

Action: When a query requires data from another query, structure it as a multi-step query, and use the result of the first query as the input to the subsequent query.

Rule 11: Fragment Usage (Mandatory)

Problem: Defining fragments that aren't used creates unnecessary code.

Solution: You must always use all defined fragments, and any unused fragments must be removed before submitting a query.

Example

fragment BasicAccountInfo on Account {
  id
  address
  ens
}

fragment VoteDetails on Vote {
    type
    amount
}

query GetVotes($input: VotesInput!) {
  votes(input: $input) {
    nodes {
      ... on Vote {
        ...VoteDetails
      }
    }
  }
}
content_copy
download
Use code with caution.
Graphql
*   **Action:** All defined fragments *must* be used, and any unused fragments *must* be removed before submitting a query.
content_copy
download
Use code with caution.

Rule 12: Data Verification (Mandatory)

Problem: The LLM may invent data, such as Ethereum addresses, and then use it as a query parameter, without verifying it. This leads to inaccurate results and potentially misleading conclusions.

Solution: The LLM must not invent any external data. If data is used as a query parameter, the LLM must attempt to verify that the data is correct using external sources. If the LLM cannot verify the data, it must explicitly state that the data is unverified, and not present it as fact. Failure to do so is a fatal error.

Specific Error Case: The LLM invents an ethereum address, and uses it to make conclusions about a specific organization.

The LLM assumed an incorrect address for L2BEAT, used the incorrect address in a query, and drew false conclusions about their voting habits.

Action: Before using external data as a query parameter, the LLM must attempt to verify its accuracy, including but not limited to:

External Lookups: Attempt to verify a key identifier (e.g., organization address, slug) through external sources (such as Etherscan, a project's official website, or social media), and use that value in queries to Tally.

Explicit Validation: In all cases where a query uses external values, and the external values could not be verified, the LLM must disclose that the data is not verified, and must not draw conclusions based on the unverified data.

Example of Verification:
If the LLM needs to get information about the organization "L2BEAT," it must first try to verify L2BEAT's organization address or slug using an external source of truth. If the LLM cannot find a valid and verifiable address, it must not proceed with the query.
For example:

The LLM must first try to obtain the L2BEAT organization ID, for example, from the Tally UI, or from external sources.

If the LLM cannot obtain the L2BEAT organization ID from an external source, the LLM must not proceed with the query.

If the LLM is able to obtain an L2BEAT organization ID, it must use that ID in its query to Tally.

If the LLM is unable to obtain a valid ID, or must use information from an unverified source, then the LLM must make explicit mention of that fact.

The LLM must make no claims or conclusions about any unverified data.

Emphasis on External Sources: The following should be considered sources of truth when creating queries that reference specific data:

Etherscan: If you are searching for an address, or a contract address, you can use Etherscan to verify that the data is correct.

Project Websites and Socials: Project websites and social accounts should be consulted to verify the claims being made.

Tally UI: The Tally user interface can be used to verify organization addresses or slugs.

Complete Schema Reference

While we cannot provide the entire schema (it would be too lengthy), here are the core types and their most commonly used fields, and examples of the input types:

type Account {
  id: ID!
  address: String!
  ens: String
  twitter: String
  name: String!
  bio: String!
  picture: String
  safes: [AccountID!]
  type: AccountType!
  votes(governorId: AccountID!): Uint256!
  proposalsCreatedCount(input: ProposalsCreatedCountInput!): Int!
}

enum AccountType {
    EOA
    SAFE
}
type Delegate {
    id: IntID!
    account: Account!
    chainId: ChainID
    delegatorsCount: Int!
    governor: Governor
    organization: Organization
    statement: DelegateStatement
    token: Token
    votesCount(blockNumber: Int): Uint256!
  }

  input DelegateInput {
    address: Address!
    governorId: AccountID
    organizationId: IntID
  }

type DelegateStatement {
    id: IntID!
    address: Address!
    organizationID: IntID!
    statement: String!
    statementSummary: String
    isSeekingDelegation: Boolean
    issues: [Issue!]
  }

type Delegation {
    id: IntID!
    blockNumber: Int!
    blockTimestamp: Timestamp!
    chainId: ChainID!
    delegator: Account!
    delegate: Account!
    organization: Organization!
    token: Token!
    votes: Uint256!
}
input DelegationInput {
    address: Address!
    tokenId: AssetID!
  }
input DelegationsInput {
  filters: DelegationsFiltersInput!
  page: PageInput
  sort: DelegationsSortInput
}
input DelegationsFiltersInput {
    address: Address!
    governorId: AccountID
    organizationId: IntID
}
input DelegationsSortInput {
    isDescending: Boolean!
    sortBy: DelegationsSortBy!
}
enum DelegationsSortBy {
  id
  votes
}

type Governor {
    id: AccountID!
    chainId: ChainID!
    contracts: Contracts!
    isIndexing: Boolean!
    isBehind: Boolean!
    isPrimary: Boolean!
    kind: GovernorKind!
    name: String!
    organization: Organization!
    proposalStats: ProposalStats!
    parameters: GovernorParameters!
    quorum: Uint256!
    slug: String!
    timelockId: AccountID
    tokenId: AssetID!
    token: Token!
    type: GovernorType!
    delegatesCount: Int!
    delegatesVotesCount: Uint256!
    tokenOwnersCount: Int!
    metadata: GovernorMetadata
  }
  type GovernorContract {
    address: Address!
    type: GovernorType!
  }

  input GovernorInput {
    id: AccountID
    slug: String
  }

type Organization {
    id: IntID!
    slug: String!
    name: String!
    chainIds: [ChainID!]!
    tokenIds: [AssetID!]!
    governorIds: [AccountID!]!
    metadata: OrganizationMetadata
    creator: Account
    hasActiveProposals: Boolean!
    proposalsCount: Int!
    delegatesCount: Int!
    delegatesVotesCount: Uint256!
    tokenOwnersCount: Int!
    endorsementService: EndorsementService
}
input OrganizationInput {
  id: IntID
  slug: String
}
input OrganizationsInput {
  filters: OrganizationsFiltersInput
  page: PageInput
  sort: OrganizationsSortInput
}
input OrganizationsFiltersInput {
  address: Address
  chainId: ChainID
  hasLogo: Boolean
    isMember: Boolean
}
input OrganizationsSortInput {
    isDescending: Boolean!
    sortBy: OrganizationsSortBy!
}

enum OrganizationsSortBy {
  id
  name
  explore
  popular
}

type Proposal {
    id: IntID!
    onchainId: String
    block: Block
    chainId: ChainID!
    creator: Account
    end: BlockOrTimestamp!
    events: [ProposalEvent!]!
    executableCalls: [ExecutableCall!]
    governor: Governor!
    metadata: ProposalMetadata!
    organization: Organization!
    proposer: Account
    quorum: Uint256
    status: ProposalStatus!
    start: BlockOrTimestamp!
    voteStats: [VoteStats!]
}
input ProposalInput {
  id: IntID
  onchainId: String
  governorId: AccountID
    includeArchived: Boolean
    isLatest: Boolean
}
type ProposalMetadata {
  title: String
  description: String
  eta: Int
  ipfsHash: String
      previousEnd: Int
      timelockId: AccountID
      txHash: Hash
      discourseURL: String
  snapshotURL: String
}

input ProposalsInput {
  filters: ProposalsFiltersInput
  page: PageInput
  sort: ProposalsSortInput
}
input ProposalsFiltersInput {
  governorId: AccountID
  includeArchived: Boolean
    isDraft: Boolean
  organizationId: IntID
  proposer: Address
}
input ProposalsSortInput {
  isDescending: Boolean!
  sortBy: ProposalsSortBy!
}
enum ProposalsSortBy {
  id
}

type Token {
    id: AssetID!
    type: TokenType!
    name: String!
    symbol: String!
    supply: Uint256!
    decimals: Int!
    eligibility: Eligibility
    isIndexing: Boolean!
    isBehind: Boolean!
}
type Vote {
    id: IntID!
    amount: Uint256!
    block: Block!
    chainId: ChainID!
    isBridged: Boolean
    proposal: Proposal!
    reason: String
    type: VoteType!
    txHash: Hash!
    voter: Account!
}
input VotesInput {
    filters: VotesFiltersInput
    page: PageInput
    sort: VotesSortInput
  }
input VotesFiltersInput {
    proposalId: IntID
    proposalIds: [IntID!]
    voter: Address
    includePendingVotes: Boolean
    type: VoteType
}
input VotesSortInput {
    isDescending: Boolean!
    sortBy: VotesSortBy!
}
enum VotesSortBy {
  id
  amount
}

enum VoteType {
    abstain
    against
    for
    pendingabstain
    pendingagainst
    pendingfor
}
content_copy
download
Use code with caution.
Graphql

Best Practices Checklist (Pre-Flight Check)

Before submitting any query, the LLM must verify that the query logic conforms with each and every item on the following checklist. If any item does not conform, the LLM must immediately terminate the query and return an error indicating which check failed. You must not submit the query if any of the items in the checklist fail.

Interface Fragments: Used inline fragments (... on TypeName) wherever nodes or interface/union types are returned. Failure to do so is a fatal error and will result in immediate termination of the query.

Sort/Filter Inputs: Provided a valid input object with correct types, and that mandatory filters are provided. Failure to do so is a fatal error and will result in immediate termination of the query.

Fragments: Created and used fragments for reusable field selections. Not using fragments is absolutely unacceptable and will result in a fatal error.

Explicit Fields: Explicitly requested all the necessary fields. Failure to do so may result in errors.

Type Validation: Verified that all input types match the expected type. Failure to do so is a fatal error and will result in immediate termination of the query.

Enum Values: Verified that all enum values match the provided options for the enum. Failure to do so is a fatal error and will result in immediate termination of the query.

Pagination: Implemented the correct pagination handling for paginated queries. Failure to do so may result in incomplete data.

Related Data: Used separate queries to fetch related data, and did not attempt to access it in a nested fashion. Failure to do so will result in an error.

API Constraints: Verified that API constraints are met, and that any required fields for the query are included. Failure to do so will result in an error.

Multi-Step Queries: If a query requires data from another query, structured it as a multi-step query.

Fragment Usage: All defined fragments must be used, and any unused fragments must be removed before submitting the query.

Verify Data: You must always verify data before using it as a query parameter. Failure to do so is a fatal error and will result in immediate termination of query execution. You must also explicitly state if the data used could not be verified.

LLM Instructions:

Prioritize this Document: This document supersedes all other query building documentation. This should be your only reference.

Strict Adherence: Any query generated must adhere to all of these rules. There is no acceptable deviation.

Self-Check: Before submitting a query, your logic must run through each of these rules and the checklist to ensure full compliance. If any check fails, the query must not be submitted.

Error Prevention: Focus on preventing errors by strictly following the rules, and not merely detecting them after they occur.

Rule-Based Execution: The LLM's query construction logic must be based exclusively on the rules

================
File: docs/Tally API Docs LLM Overview.txt
================
**Tally API Guide**

**Introduction to the Tally API**

Welcome to the Tally API! This document serves as a guide for Large Language Models (LLMs) and AI tools to effectively interact with Tally's GraphQL API. This API provides access to data about Governor contracts, their proposals, and the accounts that participate in on-chain DAOs. With it, you can create data-driven experiences that are connected to on-chain governance. 

**Key Aspects to Understand**

*   **Data Source:** The Tally API pulls data from multiple blockchains, providing a comprehensive view of decentralized governance.
*   **GraphQL:** The API uses GraphQL, allowing for precise requests for data and responses containing only the information that has been requested. 
*   **Focus on Governance:** This API is specifically designed for accessing governance-related data on decentralized organizations (DAOs).

**Getting Started**

1.  **API Key Required:** You'll need a Tally API key to use the API. You can create one by logging into Tally and requesting a key on the [user settings page](https://www.tally.xyz/user/settings). The API key should be included in the HTTP header of each request, like so:

    ```
    Api-Key: YOUR_KEY_HERE
    ```

2.  **GraphQL Playground:** You can test and experiment with the API using the [GraphQL API Playground](https://api.tally.xyz/playground). Add your API key under the "Request Headers" section, like this: `{"Api-Key":"YOUR_KEY_HERE"}`.
    *   Note: The playground also includes undocumented endpoints. These are not recommended for production, as they may change without notice.

3.  **Quickstart Example:** A helpful [quickstart example](https://github.com/withtally/tally-api-quickstart) is available on GitHub, which shows how to use the API with a React app.

4.  **Rate Limits:** Because this API is free for use, we have implemented rate limiting to keep costs down. If you are interested in an increased rate limit, please contact us at <a href="mailto:support@tally.xyz">support@tally.xyz</a>.

5. **Community:** Join our community on Discord for more help and guidance [https://discord.com/invite/sCGnpWH3m4](https://discord.com/invite/sCGnpWH3m4)

**License and Terms**

* This API is governed by an [Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0.html) license.
* The Tally terms of service can be found here: [https://static.tally.xyz/terms.html](https://static.tally.xyz/terms.html)

**API Endpoint**
* API Endpoints: `https://api.tally.xyz/query`

**How to Use this Guide**

This document details all of the methods and types in the Tally API, and it uses examples and guidelines that an LLM can use to quickly and easily construct a valid Tally API request. Be sure to pay attention to the data types and relationships between them when making queries, and make liberal use of fragments to organize your queries efficiently.


**1. Schema Overview**

This section provides a high-level overview of core types and their relationships to enable LLMs to quickly understand the data structure.

```graphql
# Core Types Overview

type Account {
  id: ID!
  address: String!
  ens: String
  twitter: String
  name: String!
  bio: String!
  picture: String
  safes: [AccountID!]
  type: AccountType!
  votes: Uint256!
  proposalsCreatedCount: Int!
}

type Delegate {
  id: IntID!
  account: Account!
  chainId: ChainID
  delegatorsCount: Int!
  governor: Governor
  organization: Organization
  statement: DelegateStatement
  token: Token
  votesCount: Uint256!
}

type Delegation {
  id: IntID!
  blockNumber: Int!
  blockTimestamp: Timestamp!
  chainId: ChainID!
  delegator: Account!
  delegate: Account!
  organization: Organization!
  token: Token!
  votes: Uint256!
}

type Governor {
    id: AccountID!
    chainId: ChainID!
    contracts: Contracts!
    isIndexing: Boolean!
    isBehind: Boolean!
    isPrimary: Boolean!
    kind: GovernorKind!
    name: String!
    organization: Organization!
    proposalStats: ProposalStats!
    parameters: GovernorParameters!
    quorum: Uint256!
    slug: String!
    timelockId: AccountID
    tokenId: AssetID!
    token: Token!
    type: GovernorType!
    delegatesCount: Int!
    delegatesVotesCount: Uint256!
    tokenOwnersCount: Int!
    metadata: GovernorMetadata
  }

type Organization {
  id: IntID!
  slug: String!
  name: String!
  chainIds: [ChainID!]!
  tokenIds: [AssetID!]!
  governorIds: [AccountID!]!
  metadata: OrganizationMetadata
  creator: Account
  hasActiveProposals: Boolean!
  proposalsCount: Int!
  delegatesCount: Int!
  delegatesVotesCount: Uint256!
  tokenOwnersCount: Int!
  endorsementService: EndorsementService
}

type Proposal {
    id: IntID!
    onchainId: String
    block: Block
    chainId: ChainID!
    creator: Account
    end: BlockOrTimestamp!
    events: [ProposalEvent!]!
    executableCalls: [ExecutableCall!]
    governor: Governor!
    metadata: ProposalMetadata!
    organization: Organization!
    proposer: Account
    quorum: Uint256
    status: ProposalStatus!
    start: BlockOrTimestamp!
    voteStats: [VoteStats!]
}

type Token {
    id: AssetID!
    type: TokenType!
    name: String!
    symbol: String!
    supply: Uint256!
    decimals: Int!
    eligibility: Eligibility
    isIndexing: Boolean!
    isBehind: Boolean!
  }
type Vote {
      id: IntID!
        amount: Uint256!
        block: Block!
        chainId: ChainID!
        isBridged: Boolean
        proposal: Proposal!
        reason: String
        type: VoteType!
        txHash: Hash!
        voter: Account!
    }


# ... (other core types can be added here if necessary for clarity)
```

**2. Fragments: The Basics**

Fragments are reusable sets of fields. They help keep your GraphQL queries clean, organized, and efficient.

**2.1. Defining Fragments:**

Use the `fragment` keyword followed by a name and the type.

```graphql
fragment BasicAccountInfo on Account {
  id
  address
  ens
}

fragment DelegateBasics on Delegate {
    id
    votesCount
    delegatorsCount
  }
```

**2.2. Using Fragments:**

Use the spread operator `...` to include a fragment within a selection set.

```graphql
query GetAccountAndDelegate($accountId: AccountID!, $delegateInput: DelegateInput!) {
    account(id: $accountId) {
      ...BasicAccountInfo
    }
    delegate(input: $delegateInput) {
        ...DelegateBasics
    }
}
```

**3. Example Queries with Fragments**

This section illustrates how fragments are used to compose queries of varying complexity.

**3.1. Basic Example: Single Fragment, One Type**

```graphql
# Example 1: Basic Account Query with Fragment
fragment AccountBasics on Account {
  id
  address
  ens
}

query GetBasicAccount($accountId: AccountID!) {
  account(id: $accountId) {
    ...AccountBasics
  }
}
```

**3.2. Intermediate Example: Multiple Fragments, Related Types**

```graphql
# Example 2: Delegate Query with Account Fragment
fragment DelegateWithAccountInfo on Delegate {
   id
    account {
        ...AccountBasics
       }
    votesCount
    }

  fragment AccountBasics on Account {
    id
    address
    ens
  }

query GetDelegate {
     delegate(input: { address: "0x123", governorId:"123"}) {
       ...DelegateWithAccountInfo
     }
   }
```

**3.3. Advanced Example: Nested Fragments, Conditional Fields**

```graphql
  fragment ProposalDetails on Proposal {
    id
    onchainId
     metadata {
      title
      description
    }
   status
     start {
        ... on Block {
          id
          timestamp
        }
         ... on BlocklessTimestamp {
            timestamp
          }
    }
    governor {
      id
      chainId
      contracts {
         governor {
            address
          }
        }
    }
  }

fragment ExecutableCallDetails on ExecutableCall{
  signature
        target
          value
        decodedCalldata {
          signature
           parameters {
              name
              type
              value
             }
          }
 }

query GetProposalWithAction($proposalInput: ProposalInput!) {
  proposal(input: $proposalInput) {
    ...ProposalDetails
        executableCalls {
         ...ExecutableCallDetails
       }
   }
}
```

**4. Pattern Recognition Guide for LLMs**

*   **`... on Type`:**  Indicates a fragment spread. The fields within the fragment are applied to the current selection at that point, within the context of the given type.
*   **Multiple Fragments on the Same Type:**  Look for reusable sets of fields for specific types.
*   **Nested Fragments**: Can show parent-child relationships within data, indicating that a fragment uses other fragments as part of its field selections.

**5. Query Construction Steps**

Here's a decision tree to guide LLMs on composing queries:

1.  **Identify Required Data Types:** Determine the core GraphQL types needed.
2.  **Check for Existing Fragments:** Look for fragments that match your data requirements.
3.  **Create New Fragments (if needed):** Compose a new fragment if no existing fragment matches.
4.  **Compose the Query:** Assemble the query by spreading appropriate fragments, aiming for clarity and minimal over-fetching.

**6. Fragment Validation Rules for LLMs**

*   **Unique Names:** Fragment names must be unique within a GraphQL document.
*   **Valid Type:** The type after `on` (e.g., `on Account`) must exist in the schema.
*   **Valid Fields:** Fields referenced within a fragment must exist on the specified type.
*   **No Circular References:** Avoid creating fragments that refer to themselves directly or indirectly.
*   **Type Compatibility:** Spread operator (`...`) should only be used on fields of the matching type.

**7. Common Fragment Errors (LLM Training Data)**

*   **Type Mismatch:** Using an `AccountBasics` fragment where a `Delegate` is expected.
*   **Unknown Fields:** Requesting a field that doesn't exist on the specified type (e.g., requesting `votes` on an Account when you are expecting a Delegation.)
*   **Circular References:** Fragment A references fragment B, which references fragment A.
*   **Fragment not defined**: Spreading a fragment which has not been declared.

**8. LLM Processing Guidelines**

*   **Parse Schema First:** Load and analyze the Tally API schema to understand the types, relationships, and available fields.
*   **Index Fragments:** Create a searchable index of fragments from examples or the schema itself for efficient reuse.
*   **Match Fragment Patterns:** Identify fragments that fit the data type and desired field set in query requirements.
*  **Type Checking** If there are types being used in an input or as a value, ensure that the type is valid.
*   **Validate Fragment Composition:** When composing a query with fragments, check that types match at each spread location and no circular references exists.
* **Minimization of fields:** Use fragments to select the required fields, to reduce the amount of data fetched from the API.

**9. Fragment Composition Patterns**

This section demonstrates advanced techniques for using fragments effectively to build complex queries.

**9.1. Combining Multiple Fragments:**

When you have multiple fragments that provide different parts of your query, simply include them in a top-level query, or another fragment, using the spread syntax (`...`). This allows you to reuse these fragments to compose more complex data requests.
```graphql
fragment GovernorDetails on Governor {
  id
  name
  chainId
   contracts {
      governor {
        address
         type
      }
    }
}

fragment GovernorOrgInfo on Governor {
  organization {
     name
     metadata {
       icon
       description
      }
   }
}

query GetGovernorAndOrgInfo($input: GovernorInput!) {
    governor(input: $input) {
        ...GovernorDetails
      ...GovernorOrgInfo
    }
}
```

**9.2. Nested Fragment Scenarios:**

If you have hierarchical data, your fragments can also be nested. This is often used for nested types that share common fields, such as in this example:

```graphql
fragment AccountDetails on Account {
  id
  address
  ens
  twitter
  name
  bio
  picture
}

fragment DelegationDetails on Delegation {
  id
  delegator {
      ...AccountDetails
  }
  delegate {
     ...AccountDetails
  }
  organization {
        name
      metadata{
          icon
       }
    }
    votes
}

query GetDelegationDetails($input: DelegationInput!) {
    delegatee(input: $input) {
       ...DelegationDetails
    }
}
```

**9.3. Handling Pagination in Fragments**

When dealing with paginated data, incorporate the `pageInfo` fields directly within a fragment. This is also useful if you use the spread operator for `PageInfo` in multiple queries.

```graphql
fragment PaginatedDelegates on Delegation {
  id
   delegator {
    address
    name
   }
  delegate {
    address
    name
  }
    votes
    organization {
      name
      slug
    }
  }

fragment PageInfoFields on PaginatedOutput {
  pageInfo {
    firstCursor
    lastCursor
    count
  }
}

query GetPaginatedDelegates($input: DelegationsInput!) {
  delegatees(input: $input) {
    nodes {
       ...PaginatedDelegates
      }
    ...PageInfoFields
    }
}
```
**9.4. Conditional Fragment Selection**

While conditional inclusion of fields within a fragment is not directly possible using `@include` or `@skip`, you can implement a fragment to get fields for several types via union types.

```graphql
fragment NodeDetails on Node {
  ... on Account {
    name
  }
  ... on Proposal {
    status
    metadata {
      description
      title
      }
    }
  ... on Governor {
      name
    }
    ... on Delegation {
        votes
    }
}

query GetNodeDetails($input: IntID!) {
  node(id: $input) {
    ...NodeDetails
  }
}
```

**10. LLM Best Practices for Fragment Composition**

*   **Modularity:** Create specific fragments for related fields, then mix and match.
*   **Hierarchy:** Use nested fragments if needed.
*   **Avoid Over-Nesting:** Keep the fragment nesting at reasonable depths.
*   **Name Appropriately:** Use descriptive and meaningful fragment names.
*   **Prioritize Reuse:** Identify common field combinations and define fragments for reuse.
*   **Combine Fragments:** Combine single-use and commonly-used fragments to increase reusability.
*   **Readability:** Keep fragments concise; too many fields in a single fragment can reduce readability.
*   **Data Structure Awareness:** Ensure fragments align with your data structure so the query results match what you expect.

**Summary:**

* Fragments are reusable pieces of query logic, making queries more efficient and maintainable.
* Fragments are used with the `fragment` keyword and the spread operator `...`.
* Fragments should match the type on which they are used.
*   Combine multiple fragments into one query using the spread operator
*   Fragments can be nested to define hierarchical relationships
*   Use union types to implement conditional inclusion of fields into a fragment
*   Create fragments with sensible names, keep them small and focused for clarity
*   Utilize pagination fragments when making use of paginated queries

================
File: prompts/query-metadata.txt
================
# Additional context for query generation and documentation responses
# Add information that helps generate better queries and documentation responses
# For example:
# - Authentication requirements (e.g., "All queries require Bearer token")
# - Common query patterns (e.g., "Queries should include pagination parameters")
# - Rate limiting details (e.g., "Max 100 requests per minute")
# - Required headers (e.g., "Content-Type must be application/json")
# - Response formats (e.g., "All responses are in JSON format")
# - Error handling (e.g., "Include error handling for 429 rate limit responses")

# Remove these example comments and add your query metadata here

================
File: prompts/service-description.txt
================
The Tally API is a GraphQL API that provides access to on-chain governance data across multiple blockchain networks. It is designed primarily for developers building decentralized applications (dApps) and tools related to decentralized autonomous organizations (DAOs) and on-chain voting. The API allows querying governance-related data such as proposals, votes, delegates, tokens, and organizations. It enables developers to create data-driven experiences connected to real-time on-chain governance activity.

================
File: prompts/system-prompt.txt
================
You are an expert at analyzing documentation and generating accurate queries and responses based on the provided documentation. When asked to generate a query, return ONLY the query with no additional explanation. When asked about documentation, provide clear, concise responses based solely on the provided documentation.

================
File: prompts/tool-metadata.txt
================
# Additional context about the API/Service for tool descriptions
# Add information that helps describe what this service is and how it should be used
# For example:
# - The intended audience (e.g., "This API is designed for enterprise developers")
# - Primary use cases (e.g., "Commonly used in IoT deployments")
# - Service category (e.g., "Part of our data processing suite")
# - Integration points (e.g., "Core component of our ML pipeline")

# Remove these example comments and add your tool description metadata here

================
File: src/services/expertService.ts
================
import Anthropic from '@anthropic-ai/sdk';
import { config } from 'dotenv';
import { readFileSync, readdirSync } from 'fs';
import { join } from 'path';

config();

const CLAUDE_API_KEY = process.env.ANTHROPIC_API_KEY;

if (!CLAUDE_API_KEY) {
  console.error('Error: The ANTHROPIC_API_KEY environment variable is missing or not set.');
  throw new Error('ANTHROPIC_API_KEY environment variable is required for the Expert Service to function.');
}

/**
 * Interface for Claude message content
 */
interface ClaudeContent {
  type: 'text' | 'image';
  text?: string;
  source?: {
    type: 'base64' | 'url';
    media_type: string;
    data: string;
  };
}

/**
 * Interface for Claude message
 */
interface ClaudeMessage {
  role: 'user' | 'assistant';
  content: string | Array<ClaudeContent>;
}

/**
 * Interface for Claude API response
 */
interface ClaudeResponse {
  id: string;
  type: 'message';
  role: 'assistant';
  model: string;
  content: Array<ClaudeContent>;
  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence';
  stop_sequence?: string;
  usage: {
    input_tokens: number;
    output_tokens: number;
  };
}

/**
 * Configuration options for ExpertService
 */
interface ExpertServiceConfig {
  apiKey?: string;
  model?: string;
  maxTokens?: number;
  docsDir?: string;
  promptsDir?: string;
}

// Add a debug logging function that only writes to stderr
function debugLog(message: string) {
  console.error(`[DEBUG] ${message}`);
}

/**
 * Service for handling documentation queries and generation using Claude
 */
export class ExpertService {
  private anthropic: Anthropic;
  private documentation: Map<string, string>;
  private systemPrompt: string;
  private toolMetadata: string = '';
  private queryMetadata: string = '';
  private readonly model: string;
  private readonly maxTokens: number;
  private readonly docsDir: string;
  private readonly promptsDir: string;
  private serviceDescription: string = '';

  /**
   * Creates a new instance of ExpertService
   * @param config - Optional configuration parameters
   */
  constructor(config?: ExpertServiceConfig) {
    this.anthropic = new Anthropic({
      apiKey: config?.apiKey || CLAUDE_API_KEY,
    });
    this.documentation = new Map();
    this.model = config?.model || 'claude-3-sonnet-20240229';
    this.maxTokens = config?.maxTokens || 1500;
    this.docsDir = config?.docsDir || join(process.cwd(), 'docs');
    this.promptsDir = config?.promptsDir || join(process.cwd(), 'prompts');
    
    // Load files synchronously
    debugLog('Loading documentation and configuration files...');
    this.loadDocumentation();
    this.systemPrompt = this.loadSystemPrompt();
    this.toolMetadata = this.loadToolMetadata();
    this.queryMetadata = this.loadQueryMetadata();
    this.serviceDescription = this.loadServiceDescription();
    debugLog('Initial file loading complete');
    
    // Validate initialization
    if (!this.systemPrompt) {
      debugLog('Warning: System prompt could not be loaded. Service may not function as expected.');
    }
    if (this.documentation.size === 0) {
      debugLog('Warning: No documentation files were loaded. Service may not function as expected.');
    }
  }

  /**
   * Loads the system prompt from file
   * @returns The system prompt string or empty string if not found
   */
  private loadSystemPrompt(): string {
    const promptPath = join(this.promptsDir, 'system-prompt.txt');
    try {
      return readFileSync(promptPath, 'utf-8');
    } catch (error) {
      debugLog(`Failed to load system prompt from ${promptPath}: ${error}`);
      return '';
    }
  }

  /**
   * Loads all documentation files from the docs directory
   */
  private loadDocumentation(): void {
    try {
      const files = readdirSync(this.docsDir)
        .filter(file => {
          // Filter out system files and non-text files
          return !file.startsWith('.') && 
                 (file.endsWith('.txt') || file.endsWith('.md') || file.endsWith('.json'));
        });

      if (files.length === 0) {
        debugLog(`No valid documentation files found in ${this.docsDir}`);
        return;
      }

      for (const file of files) {
        try {
          const filePath = join(this.docsDir, file);
          const content = readFileSync(filePath, 'utf-8');
          this.documentation.set(file, content);
          debugLog(`Successfully loaded documentation from ${file}`);
        } catch (error) {
          debugLog(`Failed to load documentation file ${file}: ${error}`);
        }
      }
    } catch (error) {
      debugLog(`Failed to read docs directory ${this.docsDir}: ${error}`);
    }
  }

  /**
   * Loads tool description metadata from file
   */
  private loadToolMetadata(): string {
    const metadataPath = join(this.promptsDir, 'tool-metadata.txt');
    try {
      const metadata = readFileSync(metadataPath, 'utf-8');
      debugLog('Successfully loaded tool metadata file');
      return metadata;
    } catch (error) {
      debugLog('No tool metadata file found - this is optional and can be added to provide additional context for tool descriptions');
      return '';
    }
  }

  /**
   * Loads query context metadata from file
   */
  private loadQueryMetadata(): string {
    const metadataPath = join(this.promptsDir, 'query-metadata.txt');
    try {
      const metadata = readFileSync(metadataPath, 'utf-8');
      debugLog('Successfully loaded query metadata file');
      return metadata;
    } catch (error) {
      debugLog('No query metadata file found - this is optional and can be added to provide additional context for queries');
      return '';
    }
  }

  /**
   * Loads the pre-generated service description
   * @returns The service description or empty string if not found
   */
  private loadServiceDescription(): string {
    const descriptionPath = join(this.promptsDir, 'service-description.txt');
    try {
      const description = readFileSync(descriptionPath, 'utf-8');
      debugLog('Successfully loaded service description');
      return description;
    } catch (error) {
      debugLog('No service description found - please run setup script first');
      return '';
    }
  }

  /**
   * Combines all loaded documentation into a single string
   * @returns Combined documentation string
   */
  getAllDocumentation(): string {
    if (this.documentation.size === 0) {
      debugLog('No documentation files are currently loaded');
      return '';
    }
    return Array.from(this.documentation.values()).join('\n\n');
  }

  /**
   * Validates and extracts text content from Claude's response
   * @param response - The response from Claude
   * @param context - Context for error messages
   * @returns The extracted text or an error message
   */
  private validateClaudeResponse(response: ClaudeResponse, context: string): string {
    if (!response?.content?.length) {
      debugLog(`Empty response from Claude for ${context}`);
      return `Error: Unable to process ${context}`;
    }

    const content = response.content[0];
    if (content.type !== 'text' || !content.text) {
      debugLog(`Unexpected response type from Claude for ${context}`);
      return `Error: Unable to process ${context}`;
    }

    return content.text;
  }

  private async callClaude(params: Parameters<typeof this.anthropic.messages.create>[0], context: string): Promise<ClaudeResponse> {
    const timeout = 30000; // 30 seconds timeout
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new Error(`Request timed out after ${timeout}ms`)), timeout);
    });

    try {
      debugLog(`Making API request to Claude for ${context}...`);
      const response = await Promise.race([
        this.anthropic.messages.create(params),
        timeoutPromise
      ]);
      debugLog('Received response from Claude');
      return response as ClaudeResponse;
    } catch (error) {
      if (error instanceof Error && error.message.includes('timed out')) {
        debugLog(`Claude API request timed out for ${context}`);
      } else {
        debugLog(`Claude API request failed for ${context}: ${error}`);
      }
      throw error;
    }
  }

  /**
   * Generates a query based on natural language request
   * @param request - The natural language request
   * @returns Generated query or error message
   */
  async generateQuery(request: string): Promise<string> {
    const startTime = Date.now();
    debugLog(`Starting query generation for: "${request}"`);
    
    try {
      const message = await this.callClaude({
        model: this.model,
        max_tokens: this.maxTokens,
        system: this.systemPrompt,
        messages: [
          {
            role: 'user',
            content: `Given this API documentation:
          
${this.getAllDocumentation()}

${this.queryMetadata ? `Additional Query Context:\n${this.queryMetadata}\n\n` : ''}

Generate a query for this request: "${request}"

Please return ONLY the query, with no additional explanation or context.`
          }
        ]
      }, `query request: "${request}"`);

      const response = this.validateClaudeResponse(message, `query request: "${request}"`);
      const duration = Date.now() - startTime;
      debugLog(`Query generation completed in ${duration}ms`);
      return response;
    } catch (error) {
      const duration = Date.now() - startTime;
      debugLog(`Query generation failed after ${duration}ms: ${error}`);
      return `Error: Unable to generate query for request: "${request}"`;
    }
  }

  /**
   * Gets information from documentation based on a question
   * @param request - The documentation question
   * @returns Response from documentation or error message
   */
  async getDocumentationResponse(request: string): Promise<string> {
    const startTime = Date.now();
    debugLog(`Starting documentation request for: "${request}"`);
    
    try {
      const message = await this.callClaude({
        model: this.model,
        max_tokens: this.maxTokens,
        system: this.systemPrompt,
        messages: [
          {
            role: 'user',
            content: `Given this API documentation:
          
${this.getAllDocumentation()}

${this.queryMetadata ? `Additional Context:\n${this.queryMetadata}\n\n` : ''}

Answer this question about the documentation: "${request}"

Please provide a clear, concise response based solely on the provided documentation and context.`
          }
        ]
      }, `documentation request: "${request}"`);

      const response = this.validateClaudeResponse(message, `documentation request: "${request}"`);
      const duration = Date.now() - startTime;
      debugLog(`Documentation request completed in ${duration}ms`);
      return response;
    } catch (error) {
      const duration = Date.now() - startTime;
      debugLog(`Documentation request failed after ${duration}ms: ${error}`);
      return `Error: Unable to process documentation request: "${request}"`;
    }
  }

  /**
   * Analyzes the documentation to generate a service description
   * @returns A promise that resolves to the service description
   */
  async analyzeDocumentation(): Promise<string> {
    // If we already have a description, return it
    if (this.serviceDescription) {
      return this.serviceDescription;
    }

    debugLog('Analyzing documentation to generate service description...');
    
    try {
      const docs = this.getAllDocumentation();
      if (!docs) {
        debugLog('No documentation available for analysis');
        return '';
      }

      debugLog(`Analyzing ${this.documentation.size} documentation files...`);
      if (this.toolMetadata) {
        debugLog('Including tool metadata in analysis');
      }
      
      const message = await this.callClaude({
        model: this.model,
        max_tokens: this.maxTokens,
        system: this.systemPrompt,
        messages: [
          {
            role: 'user',
            content: `Analyze this API documentation and provide a concise 1-2 sentence description of what this API/service is about and what it does.

Documentation:
${docs}

${this.toolMetadata ? `Additional Context:\n${this.toolMetadata}` : ''}

Your response should be direct and focused on the core functionality, suitable for use in an API tool description.`
          }
        ]
      }, 'documentation analysis');

      debugLog('Received response from Claude');
      const description = this.validateClaudeResponse(message, 'documentation analysis');
      if (!description.startsWith('Error:')) {
        debugLog('Successfully generated service description: ' + description);
        this.serviceDescription = description;
      } else {
        debugLog('Failed to generate service description: ' + description);
      }
      
      return this.serviceDescription;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      debugLog('Error analyzing documentation: ' + errorMessage);
      if (error instanceof Error && error.stack) {
        debugLog('Stack trace: ' + error.stack);
      }
      return '';
    }
  }

  /**
   * Gets the current service description
   * @returns The service description
   */
  getServiceDescription(): string {
    return this.serviceDescription;
  }

  /**
   * Reloads all documentation and metadata files and updates the service description
   * @returns A promise that resolves when the reload is complete
   */
  async reloadDocumentation(): Promise<void> {
    debugLog('Reloading documentation and metadata...');
    
    // Clear existing documentation
    this.documentation.clear();
    
    // Reload all files
    this.loadDocumentation();
    this.systemPrompt = this.loadSystemPrompt();
    this.toolMetadata = this.loadToolMetadata();
    this.queryMetadata = this.loadQueryMetadata();
    
    // Update service description
    debugLog('Updating service description...');
    await this.analyzeDocumentation();
    
    debugLog('Documentation reload complete');
  }

  /**
   * Gets the paths to the documentation and prompts directories
   * @returns Object containing the directory paths
   */
  getDirectoryPaths(): { docsDir: string; promptsDir: string } {
    return {
      docsDir: this.docsDir,
      promptsDir: this.promptsDir
    };
  }
}

================
File: src/index.ts
================
#!/usr/bin/env node
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { createServer } from "./server.js";

function debugLog(message: string) {
  console.error(`[DEBUG] ${message}`);
}

interface ServerOptions {
  model?: string;
  maxTokens?: number;
}

function parseArguments(): ServerOptions {
  const options: ServerOptions = {};
  
  for (let i = 2; i < process.argv.length; i++) {
    const arg = process.argv[i];
    if (arg === '--model' && i + 1 < process.argv.length) {
      options.model = process.argv[++i];
    } else if (arg === '--max-tokens' && i + 1 < process.argv.length) {
      const tokens = parseInt(process.argv[++i]);
      if (!isNaN(tokens)) {
        options.maxTokens = tokens;
      }
    }
  }
  
  return options;
}

async function main() {
  try {
    debugLog('Starting Expert MCP Server...');
    
    const options = parseArguments();
    if (options.model) {
      debugLog(`Using model: ${options.model}`);
    }
    if (options.maxTokens) {
      debugLog(`Max tokens: ${options.maxTokens}`);
    }
    
    const server = await createServer(options);
    const transport = new StdioServerTransport();
    
    await server.connect(transport);
    debugLog("Expert MCP Server running on stdio");
  } catch (error) {
    debugLog("Fatal error: " + error);
    process.exit(1);
  }
}

process.on('unhandledRejection', (error) => {
  debugLog('Unhandled promise rejection: ' + error);
  process.exit(1);
});

main().catch((error) => {
  debugLog("Unhandled error: " + error);
  process.exit(1);
});

================
File: src/server.ts
================
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { ExpertService } from "./services/expertService.js";
import { z } from "zod";
import { writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';

function debugLog(message: string) {
  console.error(`[DEBUG] ${message}`);
}

// Create required directories if they don't exist
const dirs = ['docs', 'prompts'].map(dir => join(process.cwd(), dir));
for (const dir of dirs) {
  if (!existsSync(dir)) {
    debugLog(`Creating directory: ${dir}`);
    mkdirSync(dir);
  }
}

// Create required files if they don't exist
const files = [
  {
    path: join(process.cwd(), 'prompts', 'system-prompt.txt'),
    content: 'You are an expert at analyzing documentation and generating accurate queries and responses based on the provided documentation and context. When asked to generate a query, return ONLY the query with no additional explanation. When asked about documentation, provide clear, concise responses that take into account both the documentation and any additional context provided. Always ensure your responses align with the intended use cases and audience specified in the context.'
  },
  {
    path: join(process.cwd(), 'prompts', 'tool-metadata.txt'),
    content: `# Additional context about the API/Service for tool descriptions
# Add information that helps describe what this service is and how it should be used
# For example:
# - The intended audience (e.g., "This API is designed for enterprise developers")
# - Primary use cases (e.g., "Commonly used in IoT deployments")
# - Service category (e.g., "Part of our data processing suite")
# - Integration points (e.g., "Core component of our ML pipeline")

# Remove these example comments and add your tool description metadata here`
  },
  {
    path: join(process.cwd(), 'prompts', 'query-metadata.txt'),
    content: `# Additional context for query generation and documentation responses
# Add information that helps generate better queries and documentation responses
# For example:
# - Authentication requirements (e.g., "All queries require Bearer token")
# - Common query patterns (e.g., "Queries should include pagination parameters")
# - Rate limiting details (e.g., "Max 100 requests per minute")
# - Required headers (e.g., "Content-Type must be application/json")
# - Response formats (e.g., "All responses are in JSON format")
# - Error handling (e.g., "Include error handling for 429 rate limit responses")

# Remove these example comments and add your query metadata here`
  }
];

for (const file of files) {
  if (!existsSync(file.path)) {
    debugLog(`Creating file: ${file.path}`);
    writeFileSync(file.path, file.content, 'utf-8');
  }
}

const QueryArgumentsSchema = z.object({
  request: z.string().min(1, 'Request cannot be empty'),
});

const DocumentationArgumentsSchema = z.object({
  request: z.string().min(1, 'Request cannot be empty'),
});

interface ServerConfig {
  model?: string;
  maxTokens?: number;
}

export async function createServer(config?: ServerConfig) {
  const expertService = new ExpertService({
    model: config?.model,
    maxTokens: config?.maxTokens,
  });

  const server = new Server(
    {
      name: "expert-server",
      version: "1.0.0",
    },
    {
      capabilities: {
        tools: {},
      },
    }
  );

  // List available tools
  server.setRequestHandler(ListToolsRequestSchema, async () => {
    // Initialize service description if not already done
    if (!expertService.getServiceDescription()) {
      debugLog('Initializing service description...');
      await expertService.analyzeDocumentation();
    }

    const baseDescription = expertService.getServiceDescription();
    const toolDescription = baseDescription ? 
      ` for ${baseDescription.toLowerCase()}` : 
      ' using the API documentation';

    return {
      tools: [
        {
          name: "create-query",
          description: `Generate a query${toolDescription}`,
          inputSchema: {
            type: "object",
            properties: {
              request: {
                type: "string",
                description: "Natural language request for the query you want to generate",
              },
            },
            required: ["request"],
          },
        },
        {
          name: "documentation",
          description: `Get information about${toolDescription}`,
          inputSchema: {
            type: "object",
            properties: {
              request: {
                type: "string",
                description: "Natural language question about the API documentation",
              },
            },
            required: ["request"],
          },
        },
      ],
    };
  });

  // Handle tool execution
  server.setRequestHandler(CallToolRequestSchema, async (request) => {
    const startTime = Date.now();
    const { name, arguments: args } = request.params;
    debugLog(`Received ${name} request with arguments: ${JSON.stringify(args)}`);

    try {
      if (name === "create-query") {
        const { request: queryRequest } = QueryArgumentsSchema.parse(args);
        const query = await expertService.generateQuery(queryRequest);
        
        if (query.startsWith('Error:')) {
          debugLog(`Query generation failed: ${query}`);
        }
        
        const response = {
          content: [
            {
              type: "text",
              text: query,
            },
          ],
        };
        
        const duration = Date.now() - startTime;
        debugLog(`Request completed in ${duration}ms with response: ${JSON.stringify(response)}`);
        return response;
      } else if (name === "documentation") {
        const { request: docRequest } = DocumentationArgumentsSchema.parse(args);
        const response = await expertService.getDocumentationResponse(docRequest);
        
        if (response.startsWith('Error:')) {
          debugLog(`Documentation request failed: ${response}`);
        }
        
        const result = {
          content: [
            {
              type: "text",
              text: response,
            },
          ],
        };
        
        const duration = Date.now() - startTime;
        debugLog(`Request completed in ${duration}ms with response: ${JSON.stringify(result)}`);
        return result;
      } else {
        throw new Error(`Unknown tool: ${name}`);
      }
    } catch (error) {
      const duration = Date.now() - startTime;
      debugLog(`Request failed after ${duration}ms: ${error}`);
      
      if (error instanceof z.ZodError) {
        const message = `Invalid arguments: ${error.errors
          .map((e) => `${e.path.join(".")}: ${e.message}`)
          .join(", ")}`;
        debugLog(message);
        throw new Error(message);
      }
      
      throw error;
    }
  });

  return server;
}

================
File: src/setup.ts
================
#!/usr/bin/env node
import { ExpertService } from './services/expertService.js';
import { writeFileSync } from 'fs';
import { join } from 'path';

async function setup() {
  console.log('Starting setup...');
  
  try {
    const expertService = new ExpertService();
    console.log('Analyzing documentation...');
    
    const description = await expertService.analyzeDocumentation();
    if (!description) {
      throw new Error('Failed to generate service description');
    }
    
    // Save the description to a file
    const descriptionPath = join(process.cwd(), 'prompts', 'service-description.txt');
    writeFileSync(descriptionPath, description, 'utf-8');
    
    console.log('Setup complete! Service description saved to prompts/service-description.txt');
    console.log('Description:', description);
    process.exit(0);
  } catch (error) {
    console.error('Setup failed:', error);
    process.exit(1);
  }
}

setup();

================
File: .env.example
================
# Anthropic API Key for Claude
ANTHROPIC_API_KEY=your_api_key_here

# Optional: API Documentation file path
API_DOCUMENTATION_PATH=path/to/your/api/documentation.txt

================
File: .gitignore
================
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build output
build/
dist/
*.tsbuildinfo

# Environment variables
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

================
File: docs.txt
================
example.txt

================
File: package.json
================
{
  "name": "expert-server",
  "version": "1.0.0",
  "description": "An MCP server for query generation and documentation assistance",
  "type": "module",
  "main": "build/index.js",
  "types": "build/index.d.ts",
  "bin": {
    "expert-server": "build/index.js"
  },
  "scripts": {
    "build": "tsc && node -e \"require('fs').chmodSync('build/index.js', '755')\"",
    "prepublishOnly": "npm run build",
    "start": "node build/index.js",
    "setup": "node build/setup.js"
  },
  "files": [
    "build",
    "README.md",
    "LICENSE"
  ],
  "keywords": [
    "typescript",
    "server",
    "mcp",
    "claude"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@anthropic-ai/sdk": "^0.17.1",
    "@modelcontextprotocol/sdk": "^1.0.0",
    "dotenv": "^16.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  },
  "engines": {
    "node": ">=18"
  }
}

================
File: README.md
================
# MCP Expert Server

A Model Context Protocol server that provides intelligent query generation and documentation assistance using Claude AI. The server analyzes your API documentation and provides two main tools:

- **create-query**: Generates queries based on natural language requests
- **documentation**: Provides relevant documentation information based on questions

## Prerequisites

- Node.js >= 18
- An Anthropic API key for Claude

## Installation

1. Clone the repository
2. Install dependencies:
```bash
npm install
```
3. Create a `.env` file with your Anthropic API key:
```
ANTHROPIC_API_KEY=your_api_key_here
```

## Setup

Before running the server, you need to:

1. Add your API documentation files to the `docs` directory (supports `.txt`, `.md`, and `.json` files)

2. Optionally customize the prompts in the `prompts` directory:
   - `system-prompt.txt`: Main system prompt for Claude
   - `tool-metadata.txt`: Additional context for tool descriptions
   - `query-metadata.txt`: Additional context for query generation

3. Run the setup script to analyze documentation and generate service description:
```bash
npm run build
npm run setup
```

## Usage

1. Start the server:
```bash
npm start
```

2. The server exposes two tools via the Model Context Protocol:

   - **create-query**: Generate a query based on natural language request
     ```json
     {
       "name": "create-query",
       "arguments": {
         "request": "Find all users who signed up in the last week"
       }
     }
     ```

   - **documentation**: Get information from the documentation
     ```json
     {
       "name": "documentation",
       "arguments": {
         "request": "How do I authenticate API requests?"
       }
     }
     ```

## Directory Structure

```
.
â”œâ”€â”€ docs/                  # Your API documentation files
â”œâ”€â”€ prompts/              # System prompts and metadata
â”‚   â”œâ”€â”€ system-prompt.txt    # Main system prompt
â”‚   â”œâ”€â”€ tool-metadata.txt    # Tool description context
â”‚   â”œâ”€â”€ query-metadata.txt   # Query generation context
â”‚   â””â”€â”€ service-description.txt  # Generated service description
â”œâ”€â”€ src/                  # Source code
â”‚   â”œâ”€â”€ index.ts            # Entry point
â”‚   â”œâ”€â”€ server.ts           # MCP server implementation
â”‚   â””â”€â”€ services/           # Core services
â”‚       â””â”€â”€ expertService.ts  # Claude integration
â””â”€â”€ package.json
```

## Development

- Build the project:
```bash
npm run build
```

- The server uses TypeScript and follows a modular architecture
- All Claude interactions are handled by the ExpertService class
- Debug logs are written to stderr with [DEBUG] prefix

## Environment Variables

- `ANTHROPIC_API_KEY`: Your Anthropic API key (required)

## License

MIT

================
File: tsconfig.json
================
{
    "compilerOptions": {
      "target": "ES2022",
      "module": "Node16",
      "moduleResolution": "Node16",
      "outDir": "./build",
      "rootDir": "./src",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules"]
}
